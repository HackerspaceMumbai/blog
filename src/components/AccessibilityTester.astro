---
// Accessibility testing component with axe-core integration
export interface Props {
  enableInDevelopment?: boolean;
  enableInProduction?: boolean;
  logToConsole?: boolean;
  reportToEndpoint?: string;
  runOnLoad?: boolean;
  runOnNavigation?: boolean;
  customRules?: object;
}

const {
  enableInDevelopment = true,
  enableInProduction = false,
  logToConsole = true,
  reportToEndpoint,
  runOnLoad = true,
  runOnNavigation = true,
  customRules = {}
} = Astro.props;

const isDevelopment = import.meta.env.DEV;
const shouldRun = (isDevelopment && enableInDevelopment) || (!isDevelopment && enableInProduction);
---

{shouldRun && (
  <script define:vars={{ logToConsole, reportToEndpoint, runOnLoad, runOnNavigation, customRules, isDevelopment }}>
    // Accessibility Testing Suite
    class AccessibilityTester {
      constructor(options = {}) {
        this.logToConsole = options.logToConsole ?? true;
        this.reportToEndpoint = options.reportToEndpoint;
        this.runOnLoad = options.runOnLoad ?? true;
        this.runOnNavigation = options.runOnNavigation ?? true;
        this.customRules = options.customRules ?? {};
        this.isDevelopment = options.isDevelopment ?? false;
        
        this.violations = [];
        this.testResults = new Map();
        
        this.init();
      }
      
      async init() {
        // Load axe-core library
        await this.loadAxeCore();
        
        // Configure axe with custom rules
        this.configureAxe();
        
        // Set up testing triggers
        this.setupTestTriggers();
        
        // Run initial test if enabled
        if (this.runOnLoad) {
          // Wait for DOM to be fully loaded
          if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => this.runAccessibilityTest());
          } else {
            this.runAccessibilityTest();
          }
        }
      }
      
      async loadAxeCore() {
        return new Promise((resolve, reject) => {
          if (typeof axe !== 'undefined') {
            resolve();
            return;
          }
          
          const script = document.createElement('script');
          script.src = 'https://unpkg.com/axe-core@4.8.2/axe.min.js';
          script.onload = () => {
            console.log('üîç Axe-core loaded for accessibility testing');
            resolve();
          };
          script.onerror = () => {
            console.error('Failed to load axe-core');
            reject(new Error('Failed to load axe-core'));
          };
          document.head.appendChild(script);
        });
      }
      
      configureAxe() {
        if (typeof axe === 'undefined') return;
        
        // Configure axe with custom rules and settings
        const axeConfig = {
          rules: {
            // Enable all rules by default
            ...this.getDefaultRules(),
            // Apply custom rules
            ...this.customRules
          },
          tags: ['wcag2a', 'wcag2aa', 'wcag21aa', 'best-practice'],
          // Exclude certain elements if needed
          exclude: [
            // Add selectors to exclude from testing
          ]
        };
        
        axe.configure(axeConfig);
      }
      
      getDefaultRules() {
        return {
          // Color contrast
          'color-contrast': { enabled: true },
          'color-contrast-enhanced': { enabled: true },
          
          // Keyboard navigation
          'focus-order-semantics': { enabled: true },
          'tabindex': { enabled: true },
          
          // ARIA
          'aria-allowed-attr': { enabled: true },
          'aria-required-attr': { enabled: true },
          'aria-valid-attr-value': { enabled: true },
          'aria-valid-attr': { enabled: true },
          
          // Images
          'image-alt': { enabled: true },
          'image-redundant-alt': { enabled: true },
          
          // Forms
          'label': { enabled: true },
          'form-field-multiple-labels': { enabled: true },
          
          // Headings
          'heading-order': { enabled: true },
          'empty-heading': { enabled: true },
          
          // Links
          'link-name': { enabled: true },
          'link-in-text-block': { enabled: true },
          
          // Page structure
          'page-has-heading-one': { enabled: true },
          'landmark-one-main': { enabled: true },
          'region': { enabled: true }
        };
      }
      
      setupTestTriggers() {
        // Test on navigation changes (for SPAs)
        if (this.runOnNavigation) {
          // Listen for URL changes
          let currentUrl = window.location.href;
          const checkUrlChange = () => {
            if (window.location.href !== currentUrl) {
              currentUrl = window.location.href;
              setTimeout(() => this.runAccessibilityTest(), 1000); // Delay to allow content to load
            }
          };
          
          // Check for URL changes periodically
          setInterval(checkUrlChange, 1000);
          
          // Listen for popstate events
          window.addEventListener('popstate', () => {
            setTimeout(() => this.runAccessibilityTest(), 500);
          });
        }
        
        // Manual testing trigger
        window.testAccessibility = () => this.runAccessibilityTest();
        
        // Keyboard shortcut for testing (Ctrl+Shift+A)
        document.addEventListener('keydown', (event) => {
          if (event.ctrlKey && event.shiftKey && event.key === 'A') {
            event.preventDefault();
            this.runAccessibilityTest();
          }
        });
      }
      
      async runAccessibilityTest(context = document) {
        if (typeof axe === 'undefined') {
          console.warn('Axe-core not loaded, skipping accessibility test');
          return;
        }
        
        try {
          console.log('üîç Running accessibility test...');
          const startTime = performance.now();
          
          const results = await axe.run(context);
          const endTime = performance.now();
          
          // Store results
          this.testResults.set(Date.now(), results);
          this.violations = results.violations;
          
          // Process results
          this.processResults(results, endTime - startTime);
          
          return results;
        } catch (error) {
          console.error('Accessibility test failed:', error);
          return null;
        }
      }
      
      processResults(results, duration) {
        const { violations, passes, incomplete, inapplicable } = results;
        
        // Log summary
        if (this.logToConsole) {
          console.group(`üîç Accessibility Test Results (${duration.toFixed(2)}ms)`);
          console.log(`‚úÖ Passed: ${passes.length}`);
          console.log(`‚ùå Violations: ${violations.length}`);
          console.log(`‚ö†Ô∏è Incomplete: ${incomplete.length}`);
          console.log(`‚ûñ Inapplicable: ${inapplicable.length}`);
          
          // Log violations in detail
          if (violations.length > 0) {
            console.group('‚ùå Accessibility Violations');
            violations.forEach(violation => this.logViolation(violation));
            console.groupEnd();
          }
          
          // Log incomplete tests
          if (incomplete.length > 0) {
            console.group('‚ö†Ô∏è Incomplete Tests (Manual Review Required)');
            incomplete.forEach(item => this.logIncomplete(item));
            console.groupEnd();
          }
          
          console.groupEnd();
        }
        
        // Send to analytics/reporting endpoint
        if (this.reportToEndpoint) {
          this.reportResults(results);
        }
        
        // Show visual indicator in development
        if (this.isDevelopment) {
          this.showVisualIndicator(violations.length);
        }
        
        // Trigger custom event
        window.dispatchEvent(new CustomEvent('accessibility-test-complete', {
          detail: { results, violations, duration }
        }));
      }
      
      logViolation(violation) {
        console.group(`üö® ${violation.id}: ${violation.description}`);
        console.log(`Impact: ${violation.impact}`);
        console.log(`Help: ${violation.helpUrl}`);
        console.log(`Tags: ${violation.tags.join(', ')}`);
        
        violation.nodes.forEach((node, index) => {
          console.group(`Element ${index + 1}:`);
          console.log('HTML:', node.html);
          console.log('Target:', node.target);
          console.log('Failure Summary:', node.failureSummary);
          
          // Highlight element in DOM (development only)
          if (this.isDevelopment) {
            this.highlightElement(node.target[0]);
          }
          
          console.groupEnd();
        });
        
        console.groupEnd();
      }
      
      logIncomplete(item) {
        console.group(`‚ö†Ô∏è ${item.id}: ${item.description}`);
        console.log(`Impact: ${item.impact}`);
        console.log(`Help: ${item.helpUrl}`);
        console.log('Manual review required for:', item.nodes.map(n => n.html).join(', '));
        console.groupEnd();
      }
      
      highlightElement(selector) {
        try {
          const element = document.querySelector(selector);
          if (element) {
            element.style.outline = '3px solid red';
            element.style.outlineOffset = '2px';
            element.setAttribute('data-a11y-violation', 'true');
            
            // Remove highlight after 5 seconds
            setTimeout(() => {
              element.style.outline = '';
              element.style.outlineOffset = '';
              element.removeAttribute('data-a11y-violation');
            }, 5000);
          }
        } catch (error) {
          console.warn('Could not highlight element:', selector);
        }
      }
      
      showVisualIndicator(violationCount) {
        // Remove existing indicator
        const existing = document.getElementById('a11y-indicator');
        if (existing) existing.remove();
        
        // Create new indicator
        const indicator = document.createElement('div');
        indicator.id = 'a11y-indicator';
        indicator.style.cssText = `
          position: fixed;
          top: 10px;
          left: 10px;
          background: ${violationCount === 0 ? '#10b981' : violationCount < 5 ? '#f59e0b' : '#ef4444'};
          color: white;
          padding: 8px 12px;
          border-radius: 6px;
          font-family: monospace;
          font-size: 12px;
          font-weight: bold;
          z-index: 10000;
          box-shadow: 0 2px 8px rgba(0,0,0,0.2);
          cursor: pointer;
          transition: all 0.3s ease;
        `;
        
        indicator.textContent = violationCount === 0 
          ? '‚úÖ A11Y: PASS' 
          : `‚ùå A11Y: ${violationCount} issues`;
        
        indicator.title = 'Click to run accessibility test again';
        indicator.addEventListener('click', () => this.runAccessibilityTest());
        
        document.body.appendChild(indicator);
        
        // Auto-hide after 10 seconds
        setTimeout(() => {
          if (indicator.parentNode) {
            indicator.style.opacity = '0.3';
          }
        }, 10000);
      }
      
      async reportResults(results) {
        try {
          const payload = {
            url: window.location.href,
            timestamp: new Date().toISOString(),
            userAgent: navigator.userAgent,
            violations: results.violations.map(v => ({
              id: v.id,
              impact: v.impact,
              description: v.description,
              nodes: v.nodes.length,
              tags: v.tags
            })),
            summary: {
              passed: results.passes.length,
              violations: results.violations.length,
              incomplete: results.incomplete.length,
              inapplicable: results.inapplicable.length
            }
          };
          
          await fetch(this.reportToEndpoint, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify(payload)
          });
        } catch (error) {
          console.warn('Failed to report accessibility results:', error);
        }
      }
      
      // Public API methods
      getViolations() {
        return this.violations;
      }
      
      getTestResults() {
        return Array.from(this.testResults.values());
      }
      
      async testElement(selector) {
        const element = document.querySelector(selector);
        if (!element) {
          console.warn('Element not found:', selector);
          return null;
        }
        
        return await this.runAccessibilityTest(element);
      }
      
      async testColorContrast() {
        if (typeof axe === 'undefined') return null;
        
        return await axe.run(document, {
          rules: {
            'color-contrast': { enabled: true },
            'color-contrast-enhanced': { enabled: true }
          }
        });
      }
      
      async testKeyboardNavigation() {
        // Test keyboard navigation programmatically
        const focusableElements = this.getFocusableElements();
        const issues = [];
        
        focusableElements.forEach((element, index) => {
          // Check if element is properly focusable
          if (!this.isProperlyFocusable(element)) {
            issues.push({
              element,
              issue: 'Element not properly focusable',
              selector: this.getSelector(element)
            });
          }
          
          // Check for focus indicators
          if (!this.hasFocusIndicator(element)) {
            issues.push({
              element,
              issue: 'Missing focus indicator',
              selector: this.getSelector(element)
            });
          }
        });
        
        return {
          totalElements: focusableElements.length,
          issues,
          passed: issues.length === 0
        };
      }
      
      getFocusableElements() {
        const selector = [
          'a[href]',
          'button:not([disabled])',
          'input:not([disabled])',
          'select:not([disabled])',
          'textarea:not([disabled])',
          '[tabindex]:not([tabindex="-1"])',
          '[contenteditable="true"]'
        ].join(', ');
        
        return Array.from(document.querySelectorAll(selector));
      }
      
      isProperlyFocusable(element) {
        try {
          const rect = element.getBoundingClientRect();
          const style = window.getComputedStyle(element);
          
          return rect.width > 0 && 
                 rect.height > 0 && 
                 style.visibility !== 'hidden' && 
                 style.display !== 'none' &&
                 !element.hasAttribute('aria-hidden');
        } catch (error) {
          return false;
        }
      }
      
      hasFocusIndicator(element) {
        // This is a simplified check - in practice, you'd want more sophisticated detection
        const style = window.getComputedStyle(element, ':focus');
        return style.outline !== 'none' || 
               style.boxShadow !== 'none' || 
               element.classList.contains('focus-visible');
      }
      
      getSelector(element) {
        if (element.id) return `#${element.id}`;
        if (element.className) return `.${element.className.split(' ')[0]}`;
        return element.tagName.toLowerCase();
      }
    }
    
    // Initialize accessibility tester
    window.accessibilityTester = new AccessibilityTester({
      logToConsole,
      reportToEndpoint,
      runOnLoad,
      runOnNavigation,
      customRules,
      isDevelopment
    });
    
    // Expose testing functions globally
    window.testAccessibility = () => window.accessibilityTester.runAccessibilityTest();
    window.testColorContrast = () => window.accessibilityTester.testColorContrast();
    window.testKeyboardNavigation = () => window.accessibilityTester.testKeyboardNavigation();
    window.getA11yViolations = () => window.accessibilityTester.getViolations();
    
    // Development helpers
    if (isDevelopment) {
      console.log('üîç Accessibility testing enabled');
      console.log('üìã Available commands:');
      console.log('  - testAccessibility() - Run full accessibility test');
      console.log('  - testColorContrast() - Test color contrast only');
      console.log('  - testKeyboardNavigation() - Test keyboard navigation');
      console.log('  - getA11yViolations() - Get current violations');
      console.log('  - Ctrl+Shift+A - Quick accessibility test');
    }
  </script>
)}

<style>
  /* Accessibility testing styles */
  [data-a11y-violation="true"] {
    position: relative;
  }
  
  [data-a11y-violation="true"]::after {
    content: "A11Y";
    position: absolute;
    top: -8px;
    right: -8px;
    background: #ef4444;
    color: white;
    font-size: 10px;
    font-weight: bold;
    padding: 2px 4px;
    border-radius: 3px;
    z-index: 1000;
    pointer-events: none;
  }
  
  /* Focus indicators for testing */
  .focus-test:focus {
    outline: 2px solid #3b82f6;
    outline-offset: 2px;
  }
  
  /* High contrast mode indicators */
  @media (prefers-contrast: high) {
    #a11y-indicator {
      border: 2px solid currentColor !important;
    }
  }
  
  /* Reduced motion support */
  @media (prefers-reduced-motion: reduce) {
    #a11y-indicator {
      transition: none !important;
    }
  }
</style>