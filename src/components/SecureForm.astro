---
// Secure form component with built-in validation and protection
export interface Props {
  action?: string;
  method?: 'GET' | 'POST';
  enctype?: string;
  novalidate?: boolean;
  class?: string;
  id?: string;
  enableCSRF?: boolean;
  enableRateLimit?: boolean;
  enableHoneypot?: boolean;
  maxSubmissions?: number;
  submissionWindow?: number; // in minutes
}

const {
  action = '',
  method = 'POST',
  enctype = 'application/x-www-form-urlencoded',
  novalidate = false,
  class: className = '',
  id = '',
  enableCSRF = true,
  enableRateLimit = true,
  enableHoneypot = true,
  maxSubmissions = 5,
  submissionWindow = 10
} = Astro.props;

// Generate unique form ID if not provided
const formId = id || `secure-form-${Math.random().toString(36).substr(2, 9)}`;
---

<form 
  id={formId}
  action={action}
  method={method}
  enctype={enctype}
  novalidate={novalidate}
  class={`secure-form ${className}`}
  data-max-submissions={maxSubmissions}
  data-submission-window={submissionWindow}
  data-enable-csrf={enableCSRF}
  data-enable-rate-limit={enableRateLimit}
  data-enable-honeypot={enableHoneypot}
>
  <!-- CSRF Protection Token (hidden) -->
  {enableCSRF && (
    <input type="hidden" name="csrf_token" id={`csrf-${formId}`} value="" />
  )}
  
  <!-- Honeypot Field (hidden from users, visible to bots) -->
  {enableHoneypot && (
    <div class="honeypot-field" aria-hidden="true">
      <label for={`honeypot-${formId}`}>Leave this field empty</label>
      <input 
        type="text" 
        name="website" 
        id={`honeypot-${formId}`}
        tabindex="-1" 
        autocomplete="off"
        value=""
      />
    </div>
  )}
  
  <!-- Form Content Slot -->
  <slot />
  
  <!-- Security Information (hidden) -->
  <input type="hidden" name="form_timestamp" id={`timestamp-${formId}`} value="" />
  <input type="hidden" name="form_signature" id={`signature-${formId}`} value="" />
</form>

<!-- Load external secure form handler -->
<script src="/src/scripts/secure-form-handler.js"></script>

<script define:vars={{ formId, enableCSRF, enableRateLimit, enableHoneypot, maxSubmissions, submissionWindow }}>
  // Initialize secure form handler with external script
    constructor(formId, options = {}) {
      this.formId = formId;
      this.form = document.getElementById(formId);
      this.enableCSRF = options.enableCSRF ?? true;
      this.enableRateLimit = options.enableRateLimit ?? true;
      this.enableHoneypot = options.enableHoneypot ?? true;
      this.maxSubmissions = options.maxSubmissions ?? 5;
      this.submissionWindow = options.submissionWindow ?? 10; // minutes
      
      this.submissionCount = 0;
      this.lastSubmissionTime = 0;
      this.isSubmitting = false;
      
      if (this.form) {
        this.init();
      }
    }
    
    init() {
      console.log(`ðŸ”’ Secure form initialized: ${this.formId}`);
      
      // Initialize security features
      if (this.enableCSRF) {
        this.initCSRFProtection();
      }
      
      if (this.enableRateLimit) {
        this.initRateLimit();
      }
      
      if (this.enableHoneypot) {
        this.initHoneypot();
      }
      
      // Set up form validation
      this.initFormValidation();
      
      // Set up submission handling
      this.initSubmissionHandling();
      
      // Set up security monitoring
      this.initSecurityMonitoring();
      
      // Generate form signature
      this.generateFormSignature();
    }
    
    initCSRFProtection() {
      const csrfInput = this.form.querySelector(`#csrf-${this.formId}`);
      if (csrfInput) {
        // Get CSRF token from session storage or generate new one
        let csrfToken = sessionStorage.getItem('csrf_token');
        if (!csrfToken) {
          csrfToken = this.generateCSRFToken();
          sessionStorage.setItem('csrf_token', csrfToken);
        }
        csrfInput.value = csrfToken;
      }
    }
    
    generateCSRFToken() {
      const array = new Uint8Array(32);
      if (typeof crypto !== 'undefined' && crypto.getRandomValues) {
        crypto.getRandomValues(array);
        return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
      } else {
        return Math.random().toString(36).substring(2) + Date.now().toString(36);
      }
    }
    
    initRateLimit() {
      // Load submission history from localStorage
      const storageKey = `form_submissions_${this.formId}`;
      const submissions = JSON.parse(localStorage.getItem(storageKey) || '[]');
      
      // Clean old submissions
      const cutoffTime = Date.now() - (this.submissionWindow * 60 * 1000);
      const recentSubmissions = submissions.filter(time => time > cutoffTime);
      
      this.submissionCount = recentSubmissions.length;
      localStorage.setItem(storageKey, JSON.stringify(recentSubmissions));
    }
    
    initHoneypot() {
      const honeypotField = this.form.querySelector(`#honeypot-${this.formId}`);
      if (honeypotField) {
        // Monitor honeypot field for bot activity
        honeypotField.addEventListener('input', () => {
          console.warn('ðŸš¨ Honeypot field filled - potential bot detected');
          this.logSecurityViolation('honeypot_triggered', 'Honeypot field was filled');
          this.disableForm('Security validation failed');
        });
        
        // Additional bot detection
        honeypotField.addEventListener('focus', () => {
          console.warn('ðŸš¨ Honeypot field focused - potential bot detected');
          this.logSecurityViolation('honeypot_focused', 'Honeypot field was focused');
        });
      }
    }
    
    initFormValidation() {
      // Real-time input validation
      const inputs = this.form.querySelectorAll('input, textarea, select');
      
      inputs.forEach(input => {
        input.addEventListener('input', () => this.validateInput(input));
        input.addEventListener('blur', () => this.validateInput(input));
        input.addEventListener('paste', (event) => {
          setTimeout(() => this.validatePastedContent(input, event), 0);
        });
      });
    }
    
    validateInput(input) {
      const value = input.value;
      const type = input.type || 'text';
      
      // Clear previous validation
      this.clearInputValidation(input);
      
      // Skip validation for hidden fields
      if (input.type === 'hidden') return;
      
      // Check for XSS attempts
      if (this.containsXSS(value)) {
        this.showInputError(input, 'Invalid characters detected');
        this.logSecurityViolation('xss_attempt', `XSS attempt in field: ${input.name}`);
        return false;
      }
      
      // Check for SQL injection attempts
      if (this.containsSQLInjection(value)) {
        this.showInputError(input, 'Invalid input detected');
        this.logSecurityViolation('sql_injection_attempt', `SQL injection attempt in field: ${input.name}`);
        return false;
      }
      
      // Type-specific validation
      switch (type) {
        case 'email':
          return this.validateEmail(input, value);
        case 'url':
          return this.validateURL(input, value);
        case 'tel':
          return this.validatePhone(input, value);
        case 'password':
          return this.validatePassword(input, value);
        default:
          return this.validateGeneral(input, value);
      }
    }
    
    validatePastedContent(input, event) {
      const pastedData = event.clipboardData?.getData('text') || input.value;
      
      if (this.containsXSS(pastedData) || this.containsSQLInjection(pastedData)) {
        console.warn('ðŸš¨ Malicious content pasted into form field');
        this.logSecurityViolation('malicious_paste', `Malicious content pasted in field: ${input.name}`);
        input.value = '';
        this.showInputError(input, 'Pasted content contains invalid characters');
      }
    }
    
    containsXSS(input) {
      const xssPatterns = [
        /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
        /javascript:/gi,
        /on\w+\s*=/gi,
        /<iframe\b[^<]*(?:(?!<\/iframe>)<[^<]*)*<\/iframe>/gi,
        /expression\s*\(/gi,
        /vbscript:/gi
      ];
      
      return xssPatterns.some(pattern => pattern.test(input));
    }
    
    containsSQLInjection(input) {
      const sqlPatterns = [
        /(\b(SELECT|INSERT|UPDATE|DELETE|DROP|CREATE|ALTER|EXEC|UNION)\b)/gi,
        /(\b(OR|AND)\s+\d+\s*=\s*\d+)/gi,
        /(;|\-\-|\/\*|\*\/)/g,
        /(\b(EXEC|EXECUTE)\s*\()/gi
      ];
      
      return sqlPatterns.some(pattern => pattern.test(input));
    }
    
    validateEmail(input, value) {
      if (!value) return true;
      
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      if (!emailRegex.test(value)) {
        this.showInputError(input, 'Please enter a valid email address');
        return false;
      }
      
      // Check for suspicious email patterns
      const suspiciousPatterns = [
        /\+.*\+/, // Multiple plus signs
        /\.{2,}/, // Multiple consecutive dots
        /@.*@/, // Multiple @ symbols
      ];
      
      if (suspiciousPatterns.some(pattern => pattern.test(value))) {
        this.showInputError(input, 'Email format appears suspicious');
        this.logSecurityViolation('suspicious_email', `Suspicious email format: ${value}`);
        return false;
      }
      
      return true;
    }
    
    validateURL(input, value) {
      if (!value) return true;
      
      try {
        const url = new URL(value);
        
        // Check for suspicious protocols
        const allowedProtocols = ['http:', 'https:', 'mailto:', 'tel:'];
        if (!allowedProtocols.includes(url.protocol)) {
          this.showInputError(input, 'Invalid URL protocol');
          this.logSecurityViolation('suspicious_protocol', `Suspicious URL protocol: ${url.protocol}`);
          return false;
        }
        
        // Check for suspicious domains
        if (this.isSuspiciousDomain(url.hostname)) {
          this.showInputError(input, 'URL appears suspicious');
          this.logSecurityViolation('suspicious_domain', `Suspicious domain: ${url.hostname}`);
          return false;
        }
        
        return true;
      } catch (error) {
        this.showInputError(input, 'Please enter a valid URL');
        return false;
      }
    }
    
    validatePhone(input, value) {
      if (!value) return true;
      
      const phoneRegex = /^[\+]?[1-9][\d]{0,15}$/;
      const cleanPhone = value.replace(/[\s\-\(\)]/g, '');
      
      if (!phoneRegex.test(cleanPhone)) {
        this.showInputError(input, 'Please enter a valid phone number');
        return false;
      }
      
      return true;
    }
    
    validatePassword(input, value) {
      if (!value) return true;
      
      const minLength = 8;
      const hasUpperCase = /[A-Z]/.test(value);
      const hasLowerCase = /[a-z]/.test(value);
      const hasNumbers = /\d/.test(value);
      const hasSpecialChar = /[!@#$%^&*(),.?":{}|<>]/.test(value);
      
      if (value.length < minLength) {
        this.showInputError(input, `Password must be at least ${minLength} characters long`);
        return false;
      }
      
      if (!hasUpperCase || !hasLowerCase || !hasNumbers || !hasSpecialChar) {
        this.showInputError(input, 'Password must contain uppercase, lowercase, numbers, and special characters');
        return false;
      }
      
      return true;
    }
    
    validateGeneral(input, value) {
      // General validation for text inputs
      const maxLength = input.getAttribute('maxlength') || 1000;
      
      if (value.length > maxLength) {
        this.showInputError(input, `Input too long (max ${maxLength} characters)`);
        return false;
      }
      
      return true;
    }
    
    isSuspiciousDomain(hostname) {
      const suspiciousPatterns = [
        /\d+\.\d+\.\d+\.\d+/, // IP addresses
        /[a-z0-9]{20,}\./, // Very long random subdomains
        /\.(tk|ml|ga|cf)$/, // Suspicious TLDs
      ];
      
      return suspiciousPatterns.some(pattern => pattern.test(hostname));
    }
    
    initSubmissionHandling() {
      this.form.addEventListener('submit', (event) => {
        event.preventDefault();
        this.handleSubmission(event);
      });
    }
    
    async handleSubmission(event) {
      if (this.isSubmitting) {
        console.warn('ðŸš¨ Form already being submitted');
        return;
      }
      
      // Validate rate limiting
      if (!this.checkRateLimit()) {
        this.showFormError('Too many submissions. Please wait before trying again.');
        return;
      }
      
      // Validate honeypot
      if (!this.validateHoneypot()) {
        this.logSecurityViolation('honeypot_validation_failed', 'Honeypot validation failed');
        this.showFormError('Security validation failed');
        return;
      }
      
      // Validate CSRF token
      if (!this.validateCSRF()) {
        this.showFormError('Security token validation failed. Please refresh and try again.');
        return;
      }
      
      // Validate all inputs
      if (!this.validateAllInputs()) {
        this.showFormError('Please correct the errors above');
        return;
      }
      
      // Check form signature
      if (!this.validateFormSignature()) {
        this.logSecurityViolation('form_tampering', 'Form signature validation failed');
        this.showFormError('Form validation failed');
        return;
      }
      
      this.isSubmitting = true;
      this.showSubmissionProgress();
      
      try {
        await this.submitForm();
        this.handleSubmissionSuccess();
      } catch (error) {
        this.handleSubmissionError(error);
      } finally {
        this.isSubmitting = false;
        this.hideSubmissionProgress();
      }
    }
    
    checkRateLimit() {
      if (!this.enableRateLimit) return true;
      
      const now = Date.now();
      const timeSinceLastSubmission = now - this.lastSubmissionTime;
      const minInterval = 5000; // 5 seconds minimum between submissions
      
      if (timeSinceLastSubmission < minInterval) {
        return false;
      }
      
      if (this.submissionCount >= this.maxSubmissions) {
        return false;
      }
      
      return true;
    }
    
    validateHoneypot() {
      if (!this.enableHoneypot) return true;
      
      const honeypotField = this.form.querySelector(`#honeypot-${this.formId}`);
      return !honeypotField || honeypotField.value === '';
    }
    
    validateCSRF() {
      if (!this.enableCSRF) return true;
      
      const csrfInput = this.form.querySelector(`#csrf-${this.formId}`);
      const storedToken = sessionStorage.getItem('csrf_token');
      
      return csrfInput && csrfInput.value === storedToken;
    }
    
    validateAllInputs() {
      const inputs = this.form.querySelectorAll('input:not([type="hidden"]), textarea, select');
      let isValid = true;
      
      inputs.forEach(input => {
        if (!this.validateInput(input)) {
          isValid = false;
        }
      });
      
      return isValid;
    }
    
    generateFormSignature() {
      const timestampInput = this.form.querySelector(`#timestamp-${this.formId}`);
      const signatureInput = this.form.querySelector(`#signature-${this.formId}`);
      
      if (timestampInput && signatureInput) {
        const timestamp = Date.now().toString();
        timestampInput.value = timestamp;
        
        // Simple signature based on form structure and timestamp
        const formData = new FormData(this.form);
        const dataString = Array.from(formData.keys()).sort().join('|') + timestamp;
        const signature = this.simpleHash(dataString);
        signatureInput.value = signature;
      }
    }
    
    validateFormSignature() {
      const timestampInput = this.form.querySelector(`#timestamp-${this.formId}`);
      const signatureInput = this.form.querySelector(`#signature-${this.formId}`);
      
      if (!timestampInput || !signatureInput) return true;
      
      const timestamp = timestampInput.value;
      const providedSignature = signatureInput.value;
      
      // Check timestamp (form should be submitted within reasonable time)
      const formAge = Date.now() - parseInt(timestamp);
      const maxAge = 30 * 60 * 1000; // 30 minutes
      
      if (formAge > maxAge) {
        return false;
      }
      
      // Validate signature
      const formData = new FormData(this.form);
      const dataString = Array.from(formData.keys()).sort().join('|') + timestamp;
      const expectedSignature = this.simpleHash(dataString);
      
      return providedSignature === expectedSignature;
    }
    
    simpleHash(str) {
      let hash = 0;
      for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32-bit integer
      }
      return hash.toString(36);
    }
    
    async submitForm() {
      const formData = new FormData(this.form);
      
      // Add security metadata
      formData.append('form_id', this.formId);
      formData.append('submission_time', Date.now().toString());
      formData.append('user_agent', navigator.userAgent);
      
      const response = await fetch(this.form.action || window.location.href, {
        method: this.form.method || 'POST',
        body: formData,
        headers: {
          'X-Requested-With': 'XMLHttpRequest'
        }
      });
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      return response;
    }
    
    handleSubmissionSuccess() {
      // Update rate limiting
      this.updateSubmissionCount();
      
      // Show success message
      this.showFormSuccess('Form submitted successfully!');
      
      // Reset form
      this.form.reset();
      
      // Regenerate security tokens
      this.initCSRFProtection();
      this.generateFormSignature();
      
      console.log('âœ… Form submitted successfully');
    }
    
    handleSubmissionError(error) {
      console.error('âŒ Form submission failed:', error);
      this.logSecurityViolation('submission_error', `Form submission failed: ${error.message}`);
      this.showFormError('Submission failed. Please try again.');
    }
    
    updateSubmissionCount() {
      const now = Date.now();
      this.lastSubmissionTime = now;
      this.submissionCount++;
      
      // Update localStorage
      const storageKey = `form_submissions_${this.formId}`;
      const submissions = JSON.parse(localStorage.getItem(storageKey) || '[]');
      submissions.push(now);
      localStorage.setItem(storageKey, JSON.stringify(submissions));
    }
    
    initSecurityMonitoring() {
      // Monitor for form tampering
      const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (mutation.type === 'childList' || mutation.type === 'attributes') {
            // Check if security fields were tampered with
            this.checkFormIntegrity();
          }
        });
      });
      
      observer.observe(this.form, {
        childList: true,
        subtree: true,
        attributes: true,
        attributeFilter: ['value', 'name', 'type']
      });
    }
    
    checkFormIntegrity() {
      // Verify security fields are still present and valid
      const csrfInput = this.form.querySelector(`#csrf-${this.formId}`);
      const honeypotInput = this.form.querySelector(`#honeypot-${this.formId}`);
      const timestampInput = this.form.querySelector(`#timestamp-${this.formId}`);
      
      if (this.enableCSRF && (!csrfInput || !csrfInput.value)) {
        this.logSecurityViolation('csrf_tampering', 'CSRF token was removed or modified');
        this.disableForm('Security validation failed');
      }
      
      if (this.enableHoneypot && !honeypotInput) {
        this.logSecurityViolation('honeypot_tampering', 'Honeypot field was removed');
        this.disableForm('Security validation failed');
      }
      
      if (!timestampInput || !timestampInput.value) {
        this.logSecurityViolation('timestamp_tampering', 'Timestamp field was removed or modified');
        this.disableForm('Security validation failed');
      }
    }
    
    disableForm(message) {
      const inputs = this.form.querySelectorAll('input, textarea, select, button');
      inputs.forEach(input => input.disabled = true);
      
      this.showFormError(message);
      
      // Add visual indication
      this.form.style.opacity = '0.5';
      this.form.style.pointerEvents = 'none';
    }
    
    // UI Helper Methods
    showInputError(input, message) {
      this.clearInputValidation(input);
      
      const error = document.createElement('div');
      error.className = 'input-error';
      error.textContent = message;
      error.style.cssText = `
        color: #ef4444;
        font-size: 0.875rem;
        margin-top: 0.25rem;
      `;
      
      input.parentNode.insertBefore(error, input.nextSibling);
      input.style.borderColor = '#ef4444';
      input.setAttribute('aria-invalid', 'true');
      input.setAttribute('aria-describedby', error.id = `error-${Date.now()}`);
    }
    
    clearInputValidation(input) {
      const error = input.parentNode.querySelector('.input-error');
      if (error) error.remove();
      
      input.style.borderColor = '';
      input.removeAttribute('aria-invalid');
      input.removeAttribute('aria-describedby');
    }
    
    showFormError(message) {
      this.clearFormMessages();
      
      const error = document.createElement('div');
      error.className = 'form-error';
      error.innerHTML = `
        <div style="background: #fef2f2; border: 1px solid #fecaca; color: #dc2626; padding: 1rem; border-radius: 0.5rem; margin-bottom: 1rem;">
          ðŸš¨ ${message}
        </div>
      `;
      
      this.form.insertBefore(error, this.form.firstChild);
    }
    
    showFormSuccess(message) {
      this.clearFormMessages();
      
      const success = document.createElement('div');
      success.className = 'form-success';
      success.innerHTML = `
        <div style="background: #f0fdf4; border: 1px solid #bbf7d0; color: #166534; padding: 1rem; border-radius: 0.5rem; margin-bottom: 1rem;">
          âœ… ${message}
        </div>
      `;
      
      this.form.insertBefore(success, this.form.firstChild);
    }
    
    clearFormMessages() {
      const messages = this.form.querySelectorAll('.form-error, .form-success');
      messages.forEach(msg => msg.remove());
    }
    
    showSubmissionProgress() {
      const submitButton = this.form.querySelector('button[type="submit"], input[type="submit"]');
      if (submitButton) {
        submitButton.disabled = true;
        submitButton.textContent = 'Submitting...';
      }
    }
    
    hideSubmissionProgress() {
      const submitButton = this.form.querySelector('button[type="submit"], input[type="submit"]');
      if (submitButton) {
        submitButton.disabled = false;
        submitButton.textContent = submitButton.getAttribute('data-original-text') || 'Submit';
      }
    }
    
    logSecurityViolation(type, message) {
      const violation = {
        type,
        message,
        formId: this.formId,
        timestamp: new Date().toISOString(),
        url: window.location.href,
        userAgent: navigator.userAgent
      };
      
      console.warn('ðŸš¨ Security Violation:', violation);
      
      // Trigger custom event
      window.dispatchEvent(new CustomEvent('form-security-violation', {
        detail: violation
      }));
    }
  }
  
  // Initialize secure form handler with external script
  if (typeof SecureFormHandler !== 'undefined') {
    new SecureFormHandler(formId, {
      enableCSRF,
      enableRateLimit,
      enableHoneypot,
      maxSubmissions,
      submissionWindow
    });
  } else {
    console.error('SecureFormHandler not loaded');
  }
</script>

<style>
  /* Secure form styles */
  .secure-form {
    position: relative;
  }
  
  /* Honeypot field - hidden from users */
  .honeypot-field {
    position: absolute;
    left: -9999px;
    width: 1px;
    height: 1px;
    overflow: hidden;
    opacity: 0;
    pointer-events: none;
  }
  
  /* Input validation styles */
  .secure-form input:invalid,
  .secure-form textarea:invalid {
    border-color: #ef4444;
  }
  
  .secure-form input:valid,
  .secure-form textarea:valid {
    border-color: #10b981;
  }
  
  /* Error message styles */
  .input-error {
    color: #ef4444;
    font-size: 0.875rem;
    margin-top: 0.25rem;
    display: block;
  }
  
  /* Security indicator */
  .secure-form::before {
    content: "ðŸ”’";
    position: absolute;
    top: -10px;
    right: -10px;
    font-size: 12px;
    opacity: 0.5;
  }
  
  /* Disabled form styles */
  .secure-form:disabled,
  .secure-form[disabled] {
    opacity: 0.5;
    pointer-events: none;
  }
  
  /* High contrast mode support */
  @media (prefers-contrast: high) {
    .secure-form input:invalid,
    .secure-form textarea:invalid {
      border-width: 2px;
    }
  }
  
  /* Reduced motion support */
  @media (prefers-reduced-motion: reduce) {
    .secure-form * {
      transition: none !important;
    }
  }
</style>